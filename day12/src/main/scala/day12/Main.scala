/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package day12

object Main {
  type State = Set[Int]
  val rawInitialState = "##.###.......#..#.##..#####...#...#######....##.##.##.##..#.#.##########...##.##..##.##...####..####"
  val initialState: State = rawInitialState.zipWithIndex.filter(_._1=='#').map(_._2).toSet

  // The rules that leave the plant alive, converted to binary, then decimal
  // (e.g., ...## would become 00011 would become 3)
  type Rules = Set[Int]
  val rules: Rules = Set(3,5,7,8,9,10,11,17,18,21,22,28,29,30,31)

  def applyRules(rules: Rules, state: State)(pot: Int): Boolean =
    rules.contains(0 | (if (state.contains(pot-2)) 16 else 0)
                     | (if (state.contains(pot-1))  8 else 0)
                     | (if (state.contains(pot+0))  4 else 0)
                     | (if (state.contains(pot+1))  2 else 0)
                     | (if (state.contains(pot+2))  1 else 0))

  def potsToConsider(state: State): Set[Int] =
    state.flatMap(i => (-2 to 2).map(_+i))

  def step(rules: Rules)(state: State): State =
    potsToConsider(state).filter(applyRules(rules, state))

  def show(state: State): String =
    (state.min to state.max).map(i => if(state.contains(i)) "#" else ".").mkString

  def run(rules: Rules, initialState: State, numSteps: Int): (State, Int) = {
    val steps = Iterator.iterate(initialState)(step(rules)).zipWithIndex.take(numSteps+1).toList
    steps.foreach{ case (state, idx) => println(s"step $idx, min ${state.min} => ${show(state)}")}
    println("="*80)
    val endState = steps.last._1
    (endState, endState.sum)
  }

  def main(args: Array[String]): Unit = {
    val ans1 = run(rules, initialState, 20)._2
    // after 111 steps (with my input), the state stabilizes and just starts marching one pot to the right on each step
    val (stableState, step120sum) = run(rules, initialState, 120)
    val ans2 = step120sum + ((50000000000L - 120) * stableState.size)
    println(s"ans1 = $ans1")
    println(s"ans2 = $ans2")
  }
}
