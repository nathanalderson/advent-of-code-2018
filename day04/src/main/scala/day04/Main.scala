/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package day04

import java.time.{Duration, LocalDateTime}
import java.time.format.DateTimeFormatter

import scala.io.Source

object Event {
  private val re_Event = raw"\[(.*)\] (.*)".r
  private val re_Shift = raw"Guard #(\d+) begins shift".r
  def fromString(s: String): Event = s match {
    case re_Event(time, event) =>
      val t = LocalDateTime.parse(time, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"))
      event match {
        case re_Shift(id) => Shift(id.toInt, t)
        case "falls asleep" => Sleep(t)
        case "wakes up" => Wake(t)
      }
  }
}
abstract class Event(val time: LocalDateTime)
case class Shift(id: Int, override val time: LocalDateTime) extends Event(time)
case class Sleep(override val time: LocalDateTime) extends Event(time)
case class Wake(override val time: LocalDateTime) extends Event(time)

case class GuardShift(id: Int, sleeps: List[Event])

object Main {
  def main(args: Array[String]): Unit = {
    val lines = Source.fromFile("input.txt").getLines.toList
    val a1 = ans1(lines)
    println(s"ans1 = ${a1._1 * a1._2}")
    val a2 = ans2(lines)
    println(s"ans2 = ${a2._1 * a2._2}")
  }

  def ans1(lines: Iterable[String]): (Int, Int) = {
    val events = getEvents(lines)
    val sorted = events.sortWith { case (l, r) =>  l.time.isBefore(r.time) }
    val guardShifts = getGuardShifts(sorted)
    val timeAsleeps = calculateSleeps(guardShifts)
    val guardTimeAsleep = totalSleepsPerGuard(timeAsleeps)
    val (sleepiestGuard, _) = guardTimeAsleep.maxBy(_._2)
    val (sleepiestMinute, _) = getSleepiestMinute(sleepiestGuard, guardShifts)
    (sleepiestGuard, sleepiestMinute)
  }

  def ans2(lines: Iterable[String]): (Int, Int) = {
    val events = getEvents(lines)
    val sorted = events.sortWith { case (l, r) =>  l.time.isBefore(r.time) }
    val guardShifts = getGuardShifts(sorted)
    val guardIds = guardShifts.map(_.id).toSet
    val guardSleepiestMinutes = guardIds.map(id => id -> getSleepiestMinute(id, guardShifts)).toMap
    val (id, (minute, _)) = guardSleepiestMinutes.maxBy(_._2._2) // by count
    (id, minute)
  }

  // returns the sleepiest minute of a guard and the number of times he was asleep for that minute
  def getSleepiestMinute(id: Int, guardShifts: List[GuardShift]): (Int, Int) = {
    val sleeps: List[Event] = guardShifts.filter(_.id == id).flatMap(_.sleeps)
    val whichMinutesAsleep = sleeps.grouped(2).flatMap {
      case List(Sleep(t1), Wake(t2)) => (t1.getMinute until t2.getMinute).toList
      case _ => throw new Exception("mismatched sleep/wake")
    }.toList
    mode(whichMinutesAsleep).getOrElse(-1,-1)
  }

  // returns the statistical mode of a list, along with the count of that value
  def mode[A](l: List[A]): Option[(A, Int)] = l match {
    case List() => None
    case _ => Some(l.groupBy(identity).mapValues(_.size).maxBy(_._2))
  }

  def totalSleepsPerGuard(timeAsleeps: List[(Int, Long)]): Map[Int, Long] =
    timeAsleeps.groupBy(_._1).mapValues(l => l.map(_._2).sum)

  def calculateSleeps(guardShifts: List[GuardShift]): List[(Int, Long)] = {
    guardShifts.map {
      case GuardShift(id, sleeps) => id -> sleeps.grouped(2).map {
        case List(Sleep(t1), Wake(t2)) => Duration.between(t1, t2).getSeconds / 60
        case _ => throw new Exception("mismatched sleep/wake")
      }.sum
    }
  }

  def getEvents(lines: Iterable[String]): List[Event] = lines.map(Event.fromString).toList

  def getGuardShifts(events: Iterable[Event], guardShifts: List[GuardShift] = List())
    : List[GuardShift]
  = events match {
    case List() => guardShifts
    case e :: es => e match {
      case Shift(id, time) => getGuardShifts(es, GuardShift(id, List()) :: guardShifts)
      case _ =>
        val GuardShift(id, sleeps)::gss = guardShifts
        getGuardShifts(es, GuardShift(id, sleeps:+e) :: gss)
    }
  }

}
